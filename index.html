<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>3Dマンデルバルブ フラクタル レンダラー (最終安定版 V2)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #222;
            color: #ddd;
            /* UI中央寄せのためのFlex設定 */
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        h1 {
            margin-top: 0;
            margin-bottom: 20px;
        }
        #container {
            display: flex;
            gap: 20px;
            max-width: 1200px;
            margin: auto; 
            flex-grow: 1; 
            align-items: center; /* 垂直方向の中央寄せ */
        }
        #controls {
            flex-shrink: 0;
            width: 300px;
            padding: 15px;
            background-color: #333;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            max-height: 80vh; 
            overflow-y: auto;
        }
        #canvasContainer {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            border: 1px solid #555;
            cursor: grab;
            display: block;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            /* キャンバスの論理サイズを維持 */
            width: 800px;
            height: 450px;
        }
        .control-group {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 0.9em;
            color: #ccc;
        }
        input[type="range"] {
            width: calc(100% - 70px);
            margin-right: 5px;
        }
        .slider-wrapper {
            display: flex;
            align-items: center;
        }
        .value-span {
            font-weight: bold;
            width: 60px;
            text-align: right;
            color: #8f8;
        }
        select, button {
            width: 100%;
            padding: 8px;
            margin-top: 5px;
            border: none;
            border-radius: 4px;
            background-color: #555;
            color: #fff;
            cursor: pointer;
        }
        button:hover {
            background-color: #666;
        }
        #resetBtn { background-color: #d9534f; }
        #resetBtn:hover { background-color: #c9302c; }
        #saveImageBtn { background-color: #5cb85c; }
        #saveImageBtn:hover { background-color: #4cae4c; }
    </style>
    <script src="gl-matrix-min.js"></script>
</head>
<body>
    <h1>3Dマンデルバルブ フラクタル レンダラー (最終安定版 V2)</h1>
    <div id="container">
        <div id="controls">
            <h2>安定性/速度設定</h2>

            <div class="control-group">
                <label>コア精度 (固定):</label>
                <div style="font-size:0.9em;">
                    StepFactor: **1.0**<br>
                    MaxIterations: **200**
                </div>
            </div>
            
            <div class="control-group">
                <label for="maxRaySteps">最大レイ追跡回数 (MaxRaySteps):</label>
                <div class="slider-wrapper">
                    <input type="range" id="maxRaySteps" min="100" max="3000" value="1400" step="100">
                    <span id="maxRayStepsValue" class="value-span">1400</span>
                </div>
            </div>

            <h2>描画設定</h2>
            
            <div class="control-group">
                <label for="powerSelect">マンデルバルブの累乗:</label>
                <select id="powerSelect">
                    <option value="8.0" selected>Power 8.0 (標準)</option>
                    <option value="2.0">Power 2.0</option>
                    <option value="3.0">Power 3.0</option>
                    <option value="4.0">Power 4.0</option>
                    <option value="5.0">Power 5.0</option>
                    <option value="6.0">Power 6.0</option>
                    <option value="7.0">Power 7.0</option>
                    <option value="9.0">Power 9.0</option>
                    <option value="10.0">Power 10.0</option>
                    <option value="-8.0">Power -8.0 (反転)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="fovSlider">視野角 (FOV):</label>
                <div class="slider-wrapper">
                    <input type="range" id="fovSlider" min="10" max="150" value="45" step="1">
                    <span id="fovValue" class="value-span">45°</span>
                </div>
            </div>

            <div class="control-group">
                <label for="maxDistance">最大描画距離:</label>
                <div class="slider-wrapper">
                    <input type="range" id="maxDistance" min="1.0" max="20.0" value="5.0" step="0.1">
                    <span id="maxDistanceValue" class="value-span">5.0</span>
                </div>
            </div>

            <div class="control-group">
                <label for="lightAngle">光源の角度:</label>
                <div class="slider-wrapper">
                    <input type="range" id="lightAngle" min="0" max="360" value="30" step="1">
                    <span id="lightAngleValue" class="value-span">30°</span>
                </div>
            </div>

            <div class="control-group">
                <label for="colorPalette">カラーパレット:</label>
                <select id="colorPalette">
                    <option value="fixed_two_color" selected>二色塗り分け (構造強調)</option>
                    <option value="rainbow">虹色 (Rainbow)</option>
                    <option value="grayscale">モノクロ (Grayscale)</option>
                    <option value="fire">炎 (Fire)</option>
                    <option value="sea">海 (Sea)</option>
                    <option value="forest">森 (Forest)</option>
                    <option value="sunset">夕焼け (Sunset)</option>
                    <option value="desert">砂漠 (Desert)</option>
                    <option value="aurora">オーロラ (Aurora)</option>
                    <option value="space">宇宙 (Space)</option>
                    <option value="candy">キャンディ (Candy)</option>
                    <option value="sepia">セピア (Sepia)</option>
                    <option value="cyberpunk">サイバーパンク (Cyberpunk)</option>
                    <option value="toxic">有毒 (Toxic)</option>
                    <option value="electric">電気 (Electric)</option>
                    <option value="random1">ランダム (グラデーション)</option>
                    <option value="random">ランダム (ノイズ)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="paletteSteps">パレットの繰り返し回数:</label>
                <div class="slider-wrapper">
                    <input type="range" id="paletteSteps" min="1" max="10" value="2" step="1">
                    <span id="paletteStepsValue" class="value-span">2</span>
                </div>
            </div>

            <div class="control-group">
                <button id="resetBtn">カメラ位置をリセット</button>
                <button id="saveImageBtn">PNGで画像を保存</button>
            </div>
        </div>
        
        <div id="canvasContainer">
            <canvas id="mandelbrotCanvas"></canvas>
        </div>
    </div>

    <script>
// gl-matrixライブラリが読み込まれている前提
document.addEventListener('DOMContentLoaded', () => {
    // ------------------------------------
    // --- WebGLセットアップ関数 --- (省略なし)
    // ------------------------------------
    function setupWebGL(canvas) {
        if (!canvas) return null;
        // alpha: falseで透過を防ぎ、パフォーマンスを向上
        const gl = canvas.getContext('webgl', { alpha: false }) || canvas.getContext('experimental-webgl', { alpha: false });
        if (!gl) { alert("お使いのブラウザはWebGLをサポートしていません。"); return null; }
        return gl;
    }
    function createShader(gl, type, source) {
        const shader = gl.createShader(type); gl.shaderSource(shader, source); gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { console.error('シェーダーのコンパイルエラー:', gl.getShaderInfoLog(shader)); gl.deleteShader(shader); return null; }
        return shader;
    }
    function createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram(); gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) { console.error('プログラムのリンクエラー（詳細）:', gl.getProgramInfoLog(program)); gl.deleteProgram(program); return null; }
        return program;
    }
    // ------------------------------------

    const canvas = document.getElementById('mandelbrotCanvas');
    if (!canvas) return;

    // --- DOM要素の取得 ---
    const powerSelect = document.getElementById('powerSelect');
    const colorPaletteSelect = document.getElementById('colorPalette');
    const paletteStepsSlider = document.getElementById('paletteSteps');
    const paletteStepsValueSpan = document.getElementById('paletteStepsValue');
    const maxRayStepsSlider = document.getElementById('maxRaySteps');
    const maxRayStepsValueSpan = document.getElementById('maxRayStepsValue');
    const lightAngleSlider = document.getElementById('lightAngle');
    const lightAngleValueSpan = document.getElementById('lightAngleValue');
    const fovSlider = document.getElementById('fovSlider');
    const fovValueSpan = document.getElementById('fovValue');
    const maxDistanceSlider = document.getElementById('maxDistance');
    const maxDistanceValueSpan = document.getElementById('maxDistanceValue');
    const resetBtn = document.getElementById('resetBtn');
    const saveImageBtn = document.getElementById('saveImageBtn');

    const gl = setupWebGL(canvas);

    if (gl) {
        // --- 解像度と描画設定 ---
        const LOGICAL_WIDTH = 800;
        const LOGICAL_HEIGHT = 450;
        const PREVIEW_WIDTH = LOGICAL_WIDTH / 2; // 400
        const PREVIEW_HEIGHT = LOGICAL_HEIGHT / 2; // 225
        
        // WebGLキャンバスの内部解像度を設定
        canvas.width = LOGICAL_WIDTH;
        canvas.height = LOGICAL_HEIGHT;
        
        // --- コア設定 ---
        const FIXED_STEP_FACTOR = 1.0;
        const HIGH_MAX_ITERATIONS = 200;
        const LOW_MAX_ITERATIONS = 50; 
        
        // --- Uniform変数とカメラの状態 ---
        let cameraPosition = vec3.fromValues(0, 0, 4);
        let cameraRotation = quat.create();
        let rotationCenter = vec3.fromValues(0, 0, 0); 
        let cameraDistance = 4; 
        
        let currentFOV = parseInt(fovSlider.value);
        let currentMaxRaySteps = parseInt(maxRayStepsSlider.value);
        let isDragging = false;
        let isPanning = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let renderTimer = null;
        
        const ROTATION_SENSITIVITY = 0.005; 
        const PAN_SENSITIVITY = 0.01;
        const ZOOM_SENSITIVITY = 0.05;

        // ------------------------------------
        // --- シェーダーコード --- (完全版)
        // ------------------------------------
        const vsSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;
        const fsSource = `
            precision highp float;

            uniform vec2 u_resolution;
            uniform vec3 u_cameraPosition;
            uniform mat4 u_cameraRotation;
            uniform int u_maxIterations;
            uniform int u_paletteId;
            uniform float u_power;
            uniform int u_paletteSteps;
            uniform float u_maxDistance;
            uniform float u_lightAngle;
            uniform float u_focalLength;
            uniform sampler2D u_paletteTexture;
            
            // 検証で確定したUniform変数
            uniform float u_stepFactor;
            uniform int u_maxRaySteps;

            vec3 hsvToRgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            // --- パレット関数群 ---
            vec3 grayscalePalette(float t) { return vec3(t); }
            vec3 rainbowPalette(float t) { return hsvToRgb(vec3(t, 1.0, 1.0)); }
            vec3 firePalette(float t) {
                float r, g, b;
                t = mod(t, 1.0);
                if (t < 0.25) { r = 0.0; g = t * 4.0; b = 0.0; } 
                else if (t < 0.5) { r = (t - 0.25) * 4.0; g = 1.0; b = 0.0; } 
                else if (t < 0.75) { r = 1.0; g = 1.0 - (t - 0.5) * 4.0; b = 0.0; } 
                else { r = 1.0; g = 0.0; b = (t - 0.75) * 4.0; }
                return vec3(r, g, b);
            }
            vec3 seaPalette(float t) { return mix(vec3(0.0, 0.1, 0.3), vec3(0.5, 0.8, 1.0), t); }
            vec3 forestPalette(float t) { return mix(vec3(0.0, 0.2, 0.0), vec3(0.6, 0.4, 0.2), t); }
            vec3 sunsetPalette(float t) { return mix(vec3(0.9, 0.4, 0.0), vec3(0.2, 0.0, 0.4), t); }
            vec3 desertPalette(float t) { return mix(vec3(0.8, 0.6, 0.3), vec3(0.4, 0.1, 0.0), t); }
            vec3 auroraPalette(float t) { return hsvToRgb(vec3(t * 0.2 + 0.3, 1.0, 0.8)); }
            vec3 spacePalette(float t) { return mix(vec3(0.0), vec3(0.8, 0.8, 1.0), pow(t, 3.0)); }
            vec3 candyPalette(float t) { return mix(vec3(1.0, 0.2, 0.6), vec3(0.4, 0.9, 1.0), t); }
            vec3 sepiaPalette(float t) { return vec3(t * 0.9, t * 0.8, t * 0.6); }
            vec3 cyberpunkPalette(float t) { return mix(vec3(0.0, 1.0, 1.0), vec3(1.0, 0.0, 1.0), t); }
            vec3 toxicPalette(float t) { return mix(vec3(0.0, 0.4, 0.0), vec3(0.4, 1.0, 0.0), t); }
            vec3 electricPalette(float t) { return mix(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.5, 0.0), t); }
            // ------------------------------------


            vec2 mandelbulb(vec3 p) {
                vec3 w = p;
                float r2 = dot(w, w);
                float dr = 1.0;
                int n = 0;
                const float ESCAPE_RADIUS = 2.0;

                for (int i = 0; i < 400; i++) { // Max iteration of 400 in shader for safety
                    if (r2 > ESCAPE_RADIUS * ESCAPE_RADIUS) break;
                    if (i > u_maxIterations) break; 
                    
                    float r = length(w);
                    float theta = acos(w.z / r) * u_power;
                    float phi = atan(w.y, w.x) * u_power;
                    dr = pow(r, u_power - 1.0) * u_power * dr + 1.0;
                    float rPow = pow(r, u_power);
                    
                    w = rPow * vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
                    w += p;
                    
                    r2 = dot(w, w);
                    n++;
                }
                return vec2(0.5 * log(r2) * sqrt(r2) / dr, float(n));
            }

            vec3 calcNormal(vec3 p) {
                vec2 e = vec2(0.004, 0.0);
                return normalize(vec3(
                    mandelbulb(p + e.xyy).x - mandelbulb(p - e.xyy).x,
                    mandelbulb(p + e.yxy).x - mandelbulb(p - e.yxy).x,
                    mandelbulb(p + e.yyx).x - mandelbulb(p - e.yyx).x
                ));
            }

            void main() {
                vec2 fragCoord = gl_FragCoord.xy;
                
                vec2 uv = (2.0 * fragCoord - u_resolution.xy) / u_resolution.y; 
                
                vec3 rayDir_local = normalize(vec3(uv.x, uv.y, -u_focalLength));
                
                vec3 rayDir = mat3(u_cameraRotation) * rayDir_local;
                
                vec3 rayPos = u_cameraPosition;
                rayPos += rayDir * 0.005; 
                
                vec2 hitInfo;
                float totalDist = 0.0;
                vec3 color = vec3(0.0);

                for (int i = 0; i < 3000; i++) { 
                    if (i > u_maxRaySteps) break; 
                    
                    hitInfo = mandelbulb(rayPos);
                    float dist = hitInfo.x;
                    
                    float stepSize = dist * u_stepFactor; 
                    
                    if (totalDist < 0.2) {
                        stepSize = min(stepSize, 0.001); 
                    } else {
                        stepSize = min(stepSize, 0.005);
                    }
                    
                    if (stepSize < 0.001 || totalDist > u_maxDistance) break;
                    
                    totalDist += stepSize;
                    rayPos += rayDir * stepSize;
                }

                if (hitInfo.x < 0.001) {
                    vec3 normal = calcNormal(rayPos);
                    
                    float angle = radians(u_lightAngle);
                    vec3 lightDir = normalize(vec3(sin(angle), 0.5, cos(angle)));
                    
                    float diff = max(0.0, dot(normal, lightDir));
                    
                    vec3 baseColor;
                    
                    // ID 15: 二色塗り分けパレット (構造強調)
                    if (u_paletteId == 15) { 
                        // カメラ位置と衝突位置のフラクタル深度を比較
                        vec2 camHitInfo = mandelbulb(u_cameraPosition);
                        float innerThreshold = float(u_maxIterations) * 0.8;

                        if (camHitInfo.y > innerThreshold) {
                            baseColor = vec3(1.0, 0.2, 0.2); // 赤色
                        } else {
                            baseColor = vec3(0.2, 0.4, 1.0); // 青色
                        }
                    } else {
                        // 既存の連続的な色付けロジック (脱出時間ベース)
                        float t = (log(hitInfo.y) / log(float(u_maxIterations))) * float(u_paletteSteps);
                        t = fract(t); 

                        // パレット選択
                        if (u_paletteId == 0) { baseColor = grayscalePalette(t); }
                        else if (u_paletteId == 1) { baseColor = rainbowPalette(t); }
                        else if (u_paletteId == 2) { baseColor = firePalette(t); }
                        else if (u_paletteId == 3) { baseColor = seaPalette(t); }
                        else if (u_paletteId == 4) { baseColor = forestPalette(t); }
                        else if (u_paletteId == 5) { baseColor = sunsetPalette(t); }
                        else if (u_paletteId == 6) { baseColor = desertPalette(t); }
                        else if (u_paletteId == 7) { baseColor = auroraPalette(t); }
                        else if (u_paletteId == 8) { baseColor = spacePalette(t); }
                        else if (u_paletteId == 9) { baseColor = candyPalette(t); }
                        else if (u_paletteId == 10) { baseColor = sepiaPalette(t); }
                        else if (u_paletteId == 11) { baseColor = cyberpunkPalette(t); }
                        else if (u_paletteId == 12) { baseColor = toxicPalette(t); }
                        else if (u_paletteId == 13) { baseColor = electricPalette(t); }
                        // ID 14: ランダムパレットテクスチャ
                        else {
                            baseColor = texture2D(u_paletteTexture, vec2(t, 0.5)).rgb;
                        }
                    }

                    color = baseColor * diff + vec3(0.1);
                } else {
                    color = vec3(0.0); // 描画失敗時 (真っ黒)
                }

                gl_FragColor = vec4(color, 1.0);
            }
        `;
        // ------------------------------------

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
        const program = createProgram(gl, vertexShader, fragmentShader);
        if (!program) return;
        gl.useProgram(program);

        // --- Uniform Locationの取得 ---
        const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
        const cameraPositionLocation = gl.getUniformLocation(program, 'u_cameraPosition');
        const cameraRotationLocation = gl.getUniformLocation(program, 'u_cameraRotation');
        const maxIterationsLocation = gl.getUniformLocation(program, 'u_maxIterations');
        const paletteIdLocation = gl.getUniformLocation(program, 'u_paletteId');
        const powerLocation = gl.getUniformLocation(program, 'u_power');
        const paletteStepsLocation = gl.getUniformLocation(program, 'u_paletteSteps');
        const maxDistanceLocation = gl.getUniformLocation(program, 'u_maxDistance');
        const lightAngleLocation = gl.getUniformLocation(program, 'u_lightAngle');
        const focalLengthLocation = gl.getUniformLocation(program, 'u_focalLength');
        const paletteTextureLocation = gl.getUniformLocation(program, 'u_paletteTexture');
        const stepFactorLocation = gl.getUniformLocation(program, 'u_stepFactor');
        const maxRayStepsLocation = gl.getUniformLocation(program, 'u_maxRaySteps');

        // --- バッファ設定 ---
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1, 1, -1, -1, 1,
            -1, 1, 1, -1, 1, 1
        ]), gl.STATIC_DRAW);
        const positionLocation = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        
        // --- パレットマップ ---
        const paletteMap = {
            'grayscale': 0, 'rainbow': 1, 'fire': 2, 'sea': 3, 'forest': 4,
            'sunset': 5, 'desert': 6, 'aurora': 7, 'space': 8, 'candy': 9,
            'sepia': 10, 'cyberpunk': 11, 'toxic': 12, 'electric': 13,
            'random': 14, 'random1': 14, 
            'fixed_two_color': 15,
        };
        
        // --- ランダムパレットテクスチャの準備 ---
        const randomPaletteTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, randomPaletteTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        // MIN/MAGフィルタ設定はrender()関数内でLow/Highに応じて切り替えます

        // HSV to RGB (JS用)
        function hsvToRgb(h, s, v) {
            let r, g, b;
            const i = Math.floor(h * 6);
            const f = h * 6 - i;
            const p = v * (1 - s);
            const q = v * (1 - f * s);
            const t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }
            return [r * 255, g * 255, b * 255];
        }
        
        // ランダムパレットの生成 (JS用)
        function generateSmoothRandomPalette() {
            const palette = new Uint8Array(256 * 4);
            const numPoints = 10;
            const points = [];
            for (let i = 0; i < numPoints; i++) {
                points.push([Math.random(), Math.random(), Math.random()]);
            }
            
            for (let i = 0; i < 256; i++) {
                const t = i / 255.0;
                const index = Math.floor(t * (numPoints - 1));
                const p1 = points[index];
                const p2 = points[index + 1];
                const localT = (t * (numPoints - 1)) - index;
                
                const r = p1[0] * (1 - localT) + p2[0] * localT;
                const g = p1[1] * (1 - localT) + p2[1] * localT;
                const b = p1[2] * (1 - localT) + p2[2] * localT;
                
                palette[i * 4] = r * 255;
                palette[i * 4 + 1] = g * 255;
                palette[i * 4 + 2] = b * 255;
                palette[i * 4 + 3] = 255;
            }
            return palette;
        }


        // --- 描画関数 ---
        function render(quality = 'high') {
            const isLow = (quality === 'low');
            
            // Lowモードの場合、シェーダーに渡す解像度を半分にする
            const shaderWidth = isLow ? PREVIEW_WIDTH : LOGICAL_WIDTH;
            const shaderHeight = isLow ? PREVIEW_HEIGHT : LOGICAL_HEIGHT;
            
            // ★ Lowモード時のビューポートとフィルタリングの調整
            if (isLow) {
                 // Low解像度で描画し、全キャンバスサイズに引き伸ばす
                gl.viewport(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT); 
                // ピクセルが粗くなるようにNearestフィルタリングを使用
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            } else {
                // High解像度で描画し、通常のLinearフィルタリングに戻す
                gl.viewport(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            }

            // シェーダー内の解像度を正しく設定
            gl.uniform2f(resolutionLocation, shaderWidth, shaderHeight);
            
            const maxIterations = isLow ? LOW_MAX_ITERATIONS : HIGH_MAX_ITERATIONS;
            const maxRaySteps = currentMaxRaySteps; 
            
            // --- Uniform変数の設定 ---
            gl.uniform1i(maxIterationsLocation, maxIterations);
            gl.uniform1i(maxRayStepsLocation, maxRaySteps);
            gl.uniform1f(stepFactorLocation, FIXED_STEP_FACTOR); 

            gl.uniform3f(cameraPositionLocation, cameraPosition[0], cameraPosition[1], cameraPosition[2]);
            const cameraRotationMatrix = mat4.create();
            mat4.fromQuat(cameraRotationMatrix, cameraRotation);
            gl.uniformMatrix4fv(cameraRotationLocation, false, cameraRotationMatrix);

            const paletteId = paletteMap[colorPaletteSelect.value] || 15;
            gl.uniform1i(paletteIdLocation, paletteId);
            gl.uniform1f(powerLocation, parseFloat(powerSelect.value));
            gl.uniform1i(paletteStepsLocation, parseInt(paletteStepsSlider.value));

            gl.uniform1f(maxDistanceLocation, parseFloat(maxDistanceSlider.value));
            gl.uniform1f(lightAngleLocation, parseFloat(lightAngleSlider.value));
            
            const focalLength = 1.0 / Math.tan(currentFOV * 0.5 * Math.PI / 180.0);
            gl.uniform1f(focalLengthLocation, focalLength);

            if (colorPaletteSelect.value === 'random' || colorPaletteSelect.value === 'random1') {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, randomPaletteTexture);
                gl.uniform1i(paletteTextureLocation, 0);
            }

            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }
        
        function scheduleHighQualityRender() {
            if (renderTimer) {
                clearTimeout(renderTimer);
            }
            renderTimer = setTimeout(() => {
                render('high');
            }, 50);
        }

        // --- イベントリスナー ---
        
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            isPanning = e.shiftKey;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            canvas.style.cursor = 'grabbing';
            render('low'); // 低画質プレビュー開始
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            isPanning = false;
            canvas.style.cursor = 'grab';
            scheduleHighQualityRender(); // 高画質描画
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;

                if (isPanning) {
                    // パンのロジック
                    const right = vec3.fromValues(1, 0, 0);
                    const up = vec3.fromValues(0, 1, 0);
                    vec3.transformQuat(right, right, cameraRotation);
                    vec3.transformQuat(up, up, cameraRotation);
                    const panAmountX = -dx * PAN_SENSITIVITY;
                    const panAmountY = dy * PAN_SENSITIVITY;
                    vec3.scaleAndAdd(cameraPosition, cameraPosition, right, panAmountX);
                    vec3.scaleAndAdd(cameraPosition, cameraPosition, up, panAmountY);
                    vec3.scaleAndAdd(rotationCenter, rotationCenter, right, panAmountX);
                    vec3.scaleAndAdd(rotationCenter, rotationCenter, up, panAmountY);
                } else {
                    // 回転ロジック
                    const xRotation = -dy * ROTATION_SENSITIVITY;
                    const yRotation = -dx * ROTATION_SENSITIVITY;
                    
                    const camRight = vec3.fromValues(1, 0, 0);
                    const camUp = vec3.fromValues(0, 1, 0);
                    vec3.transformQuat(camRight, camRight, cameraRotation);
                    vec3.transformQuat(camUp, camUp, cameraRotation);
                    
                    const newRotationX = quat.create();
                    quat.setAxisAngle(newRotationX, camRight, xRotation);
                    const newRotationY = quat.create();
                    quat.setAxisAngle(newRotationY, camUp, yRotation);
                    
                    quat.multiply(cameraRotation, newRotationX, cameraRotation);
                    quat.multiply(cameraRotation, cameraRotation, newRotationY); 
                    
                    // カメラ位置の再計算: カメラ位置 = 回転中心 + (回転後の相対位置)
                    const relativePos = vec3.create();
                    vec3.set(relativePos, 0, 0, cameraDistance);
                    vec3.transformQuat(relativePos, relativePos, cameraRotation);
                    vec3.add(cameraPosition, rotationCenter, relativePos);
                }
                
                render('low'); // Low画質で即時描画
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomAmount = Math.log(Math.abs(e.deltaY) + 1) * Math.sign(e.deltaY) * ZOOM_SENSITIVITY;
            
            cameraDistance -= zoomAmount;
            if (cameraDistance < 0.1) cameraDistance = 0.1;

            // カメラ位置の再計算: カメラ位置 = 回転中心 + (回転後の相対位置)
            const relativePos = vec3.create();
            vec3.set(relativePos, 0, 0, cameraDistance);
            vec3.transformQuat(relativePos, relativePos, cameraRotation);
            vec3.add(cameraPosition, rotationCenter, relativePos);

            render('low'); 
            scheduleHighQualityRender();
        });
        
        // --- コントロールのイベントリスナー ---
        
        maxRayStepsSlider.addEventListener('input', () => {
            currentMaxRaySteps = parseInt(maxRayStepsSlider.value);
            maxRayStepsValueSpan.textContent = currentMaxRaySteps;
            render('low');
        });
        maxRayStepsSlider.addEventListener('change', () => {
            scheduleHighQualityRender();
        });

        const controlsToUpdate = [powerSelect, colorPaletteSelect, paletteStepsSlider, maxDistanceSlider, lightAngleSlider, fovSlider];

        controlsToUpdate.forEach(control => {
            control.addEventListener('input', () => {
                if (control.id === 'fovSlider') {
                    currentFOV = parseInt(control.value);
                    fovValueSpan.textContent = control.value + '°';
                } else if (control.id === 'lightAngle') {
                    lightAngleValueSpan.textContent = control.value + '°';
                } else if (control.id === 'maxDistance') {
                    maxDistanceValueSpan.textContent = control.value;
                } else if (control.id === 'paletteSteps') {
                    paletteStepsValueSpan.textContent = control.value;
                }
                render('low');
            });
            control.addEventListener('change', () => {
                scheduleHighQualityRender();
            });
        });

        resetBtn.addEventListener('click', () => {
            vec3.set(cameraPosition, 0, 0, 4);
            quat.identity(cameraRotation);
            vec3.set(rotationCenter, 0, 0, 0);
            cameraDistance = 4;
            currentFOV = 45;
            fovSlider.value = 45;
            fovValueSpan.textContent = '45°';
            lightAngleSlider.value = 30; // リセット時も30度
            lightAngleValueSpan.textContent = '30°';
            render('high');
        });

        saveImageBtn.addEventListener('click', () => {
            render('high'); 
            const dataURL = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'mandelbulb_fractal.png';
            link.href = dataURL;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        // --- 初期描画ロジック ---
        // ランダムパレットテクスチャのデータ設定
        const currentRandomPalette = generateSmoothRandomPalette();
        gl.bindTexture(gl.TEXTURE_2D, randomPaletteTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 256, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, currentRandomPalette);
        
        // ★ 初期画面表示を確実にするためのHigh品質描画
        render('high');
    }
});
    </script>
</body>
</html>